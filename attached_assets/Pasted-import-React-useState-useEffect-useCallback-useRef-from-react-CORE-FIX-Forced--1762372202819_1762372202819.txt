import React, { useState, useEffect, useCallback, useRef } from 'react';

// --- CORE FIX: Forced Relative WebSocket URL Construction ---

// This function forces the use of the current window's location to construct 
// the base URL, ignoring any potentially stale VITE_WS_URL environment variables.
const getWebSocketBaseUrl = () => {
    // 1. Determine the secure/unsecure prefix
    const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
    
    // 2. Use the current host/domain. This must match the address in the browser bar.
    const host = window.location.host;
    
    // Log the base URL that should now use the host/domain and avoid the stale absolute URL
    console.log(`âœ… Proxy-Optimized WS Base URL: ${protocol}${host}`);
    
    return `${protocol}${host}`;
};


// --- USE STREAMING STT HOOK ---

// Define the required audio configuration for Google Speech-to-Text
const AUDIO_CONFIG = {
    sampleRate: 16000,
    mimeType: 'audio/webm; codecs=opus', // Common format for browser audio streaming
};

const useStreamingSTT = (token, onTranscriptUpdate, onRecognitionComplete) => {
    const [isListening, setIsListening] = useState(false);
    const wsRef = useRef(null);
    const mediaRecorderRef = useRef(null);
    const audioStreamRef = useRef(null);
    
    // Use the fixed URL function
    const WS_URL_BASE = getWebSocketBaseUrl();

    const startListening = useCallback(async () => {
        if (!token || isListening) return;

        try {
            // 1. Get Microphone Access
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioStreamRef.current = stream;
            
            // 2. Open WebSocket Connection
            // We append '/stt-stream' to the host URL, which triggers the Vite proxy.
            const wsUrl = `${WS_URL_BASE}/stt-stream?token=${token}`;
            wsRef.current = new WebSocket(wsUrl);
            
            console.log(`ðŸ” Attempting to connect WebSocket to URL: ${wsUrl}`);
            
            wsRef.current.onopen = () => {
                setIsListening(true);
                console.log('ðŸ”— STT WebSocket connected.');
                
                // 3. Initialize Media Recorder and Start Streaming
                mediaRecorderRef.current = new MediaRecorder(stream, { mimeType: AUDIO_CONFIG.mimeType });
                
                mediaRecorderRef.current.ondataavailable = (event) => {
                    if (event.data.size > 0 && wsRef.current?.readyState === WebSocket.OPEN) {
                        // Send audio chunk (Blob) to the backend over WebSocket
                        wsRef.current.send(event.data);
                    }
                };
                
                // Start collecting chunks (e.g., every 500ms)
                mediaRecorderRef.current.start(500);
            };

            wsRef.current.onmessage = (event) => {
                // The backend sends transcript text back
                const message = JSON.parse(event.data);
                
                if (message.transcript) {
                    onTranscriptUpdate(message.transcript);
                }
                
                if (message.isFinal) {
                    onRecognitionComplete(message.transcript);
                }
            };

            wsRef.current.onerror = (e) => {
                console.error('WebSocket error:', e);
                // Attempt to close gracefully on error
                stopListening(); 
            };
            
            wsRef.current.onclose = () => {
                console.log('ðŸ”Œ STT WebSocket closed.');
                setIsListening(false);
            };

        } catch (error) {
            console.error('Error starting STT:', error);
            // Replaced alert() with console logging
            console.error(`Microphone Error: ${error.name}. Please ensure your browser has permission.`);
            setIsListening(false);
        }
    }, [token, isListening, onTranscriptUpdate, onRecognitionComplete]);

    const stopListening = useCallback(() => {
        if (!isListening) return;

        // 1. Stop Media Recorder
        if (mediaRecorderRef.current?.state !== 'inactive') {
            mediaRecorderRef.current.stop();
        }

        // 2. Close WebSocket
        if (wsRef.current?.readyState === WebSocket.OPEN) {
            wsRef.current.close();
        }

        // 3. Stop Microphone Stream
        audioStreamRef.current?.getTracks().forEach(track => track.stop());

        setIsListening(false);
    }, [isListening]);

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            stopListening();
        };
    }, [stopListening]);

    return { isListening, startListening, stopListening };
};

export default useStreamingSTT;
